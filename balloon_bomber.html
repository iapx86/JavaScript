<!doctype html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Balloon Bomber</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head>
<body>
<canvas id="canvas" width="224" height="256"></canvas>
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="jquery.zip.js"></script>
<script src="i8080.js"></script>
<script src="gamepad.js"></script>
<script src="main.js"></script>
<script>
/*
 *
 *	Balloon Bomber
 *
 */

class BalloonBomber {
	constructor() {
		this.cxScreen = 224;
		this.cyScreen = 256;
		this.width = 256;
		this.height = 256;
		this.xOffset = 0;
		this.yOffset = 0;
		this.fReset = false;
		this.fTest = false;
		this.fDIPSwitchChanged = true;
		this.fCoin = 0;
		this.fStart1P = 0;
		this.fStart2P = 0;
		this.nStock = 3;
		this.nExtend = 1500;

		// CPU周りの初期化
		this.ram = new Uint8Array(0x2000);
		this.io = new Uint8Array(0x100);

		this.cpu = new I8080(this);
		for (let i = 0; i < 0x20; i++)
			this.cpu.memorymap[i].base = PRG1.subarray(i * 0x100);
		for (let i = 0; i < 8; i++)
			this.cpu.memorymap[0x40 + i].base = PRG2.subarray(i * 0x100);
		for (let i = 0; i < 0x20; i++) {
			this.cpu.memorymap[0x20 + i].base = this.ram.subarray(i * 0x100);
			this.cpu.memorymap[0x20 + i].write = null; // ramarea
		}
		for (let i = 0; i < 0x100; i++) {
			this.cpu.iomap[i].base = this.io;
			this.cpu.iomap[i].write = (addr, data, game) => {
				switch (addr & 0xff) {
				case 0x00:
				case 0x01:
				case 0x02:
					this.shifter.shift = data & 7;
					break;
				case 0x03:
//					check_sound3(this, data);
					this.screen_red = (data & 4) !== 0;
					break;
				case 0x04:
					this.io[3] = (data << game.shifter.shift | game.shifter.reg >>> (8 - game.shifter.shift)) & 0xff;
					this.shifter.reg = data;
					break;
				case 0x05:
//					check_sound5(this, data);
					break;
				default:
					this.io[addr & 0xff] = data;
					break;
				}
			};
		}

		// DIPSW SETUP
		this.io[1] = 0;

		// Videoの初期化
		this.shifter = {shift: 0, reg: 0};
		this.screen_red = false;
	}

	execute() {
		this.cpu.execute(0x0800);
		this.cpu.interrupt(0xd7); // RST 10h
		this.cpu.execute(0x0800);
		this.cpu.interrupt(0xcf); // RST 08h
		return this;
	}

	reset() {
		this.fReset = true;
	}

	updateStatus() {
		// DIPスイッチの更新
		if (this.fDIPSwitchChanged) {
			this.fDIPSwitchChanged = false;
			switch (this.nStock) {
			case 3:
				this.io[2] &= ~3;
				break;
			case 4:
				this.io[2] = this.io[2] & ~3 | 1;
				break;
			case 5:
				this.io[2] = this.io[2] & ~3 | 2;
				break;
			case 6:
				this.io[2] |= 3;
				break;
			}
			switch (this.nExtend) {
			case 1000:
				this.io[2] |= 8;
				break;
			case 1500:
				this.io[2] &= ~8;
				break;
			}
			this.fReset = true;
		}

		// リセット処理
		if (this.fReset) {
			this.fReset = false;
			this.ram.fill(0);
			this.cpu.reset();
		}
		return this;
	}

	updateInput() {
		// クレジット/スタートボタン処理
		if (this.fCoin) {
			--this.fCoin;
			this.io[1] |= 1 << 0;
		}
		else
			this.io[1] &= ~(1 << 0);
		if (this.fStart1P) {
			--this.fStart1P;
			this.io[1] |= 1 << 2;
		}
		else
			this.io[1] &= ~(1 << 2);
		if (this.fStart2P) {
			--this.fStart2P;
			this.io[1] |= 1 << 1;
		}
		else
			this.io[1] &= ~(1 << 1);
		return this;
	}

	coin() {
		this.fCoin = 2;
	}

	start1P() {
		this.fStart1P = 2;
	}

	start2P() {
		this.fStart2P = 2;
	}

	up(fDown) {
	}

	right(fDown) {
		if (fDown)
			this.io[1] = this.io[1] & ~(1 << 5) | 1 << 6;
		else
			this.io[1] &= ~(1 << 6);
	}

	down(fDown) {
	}

	left(fDown) {
		if (fDown)
			this.io[1] = this.io[1] & ~(1 << 6) | 1 << 5;
		else
			this.io[1] &= ~(1 << 5);
	}

	triggerA(fDown) {
		if (fDown)
			this.io[1] |= 1 << 4;
		else
			this.io[1] &= ~(1 << 4);
	}

	triggerB(fDown) {
	}

	makeBitmap(data) {
		const rgb = new Uint32Array([
			0xff000000, // black
			0xff0000ff, // red
			0xffff0000, // blue
			0xffff00ff, // magenta
			0xff00ff00, // green
			0xff00ffff, // yellow
			0xffffff00, // cyan
			0xffffffff, // white
		]);

		for (let p = 256 * 8 * 31, k = 0x0400, i = 256 >>> 3; i !== 0; --i) {
			for (let j = 224 >>> 2; j !== 0; k += 0x80, p += 4, --j) {
				const color = rgb[this.screen_red ? 1 : MAP[k >>> 3 & 0x3e0 | k & 0x1f] & 7];
				const back = rgb[2];
				let a = this.ram[k];
				data[p + 7 * 256] = (a & 1) !== 0 ? color : back;
				data[p + 6 * 256] = (a & 2) !== 0 ? color : back;
				data[p + 5 * 256] = (a & 4) !== 0 ? color : back;
				data[p + 4 * 256] = (a & 8) !== 0 ? color : back;
				data[p + 3 * 256] = (a & 0x10) !== 0 ? color : back;
				data[p + 2 * 256] = (a & 0x20) !== 0 ? color : back;
				data[p + 256] = (a & 0x40) !== 0 ? color : back;
				data[p] = (a & 0x80) !== 0 ? color : back;
				a = this.ram[k + 0x20];
				data[p + 1 + 7 * 256] = (a & 1) !== 0 ? color : back;
				data[p + 1 + 6 * 256] = (a & 2) !== 0 ? color : back;
				data[p + 1 + 5 * 256] = (a & 4) !== 0 ? color : back;
				data[p + 1 + 4 * 256] = (a & 8) !== 0 ? color : back;
				data[p + 1 + 3 * 256] = (a & 0x10) !== 0 ? color : back;
				data[p + 1 + 2 * 256] = (a & 0x20) !== 0 ? color : back;
				data[p + 1 + 256] = (a & 0x40) !== 0 ? color : back;
				data[p + 1] = (a & 0x80) !== 0 ? color : back;
				a = this.ram[k + 0x40];
				data[p + 2 + 7 * 256] = (a & 1) !== 0 ? color : back;
				data[p + 2 + 6 * 256] = (a & 2) !== 0 ? color : back;
				data[p + 2 + 5 * 256] = (a & 4) !== 0 ? color : back;
				data[p + 2 + 4 * 256] = (a & 8) !== 0 ? color : back;
				data[p + 2 + 3 * 256] = (a & 0x10) !== 0 ? color : back;
				data[p + 2 + 2 * 256] = (a & 0x20) !== 0 ? color : back;
				data[p + 2 + 256] = (a & 0x40) !== 0 ? color : back;
				data[p + 2] = (a & 0x80) !== 0 ? color : back;
				a = this.ram[k + 0x60];
				data[p + 3 + 7 * 256] = (a & 1) !== 0 ? color : back;
				data[p + 3 + 6 * 256] = (a & 2) !== 0 ? color : back;
				data[p + 3 + 5 * 256] = (a & 4) !== 0 ? color : back;
				data[p + 3 + 4 * 256] = (a & 8) !== 0 ? color : back;
				data[p + 3 + 3 * 256] = (a & 0x10) !== 0 ? color : back;
				data[p + 3 + 2 * 256] = (a & 0x20) !== 0 ? color : back;
				data[p + 3 + 256] = (a & 0x40) !== 0 ? color : back;
				data[p + 3] = (a & 0x80) !== 0 ? color : back;
			}
			k -= 0x20 * 224 - 1;
			p -= 224 + 256 * 8;
		}
	}
}

/*
 *
 *	Balloon Bomber
 *
 */

const filename = 'ballbomb.zip';
let PRG1, PRG2, MAP;

$.ajax({
	url: filename,
	success: function(zip) {
		PRG1 = Uint8Array.from(zip.files['tn01'].inflate() + zip.files['tn02'].inflate() + zip.files['tn03'].inflate() + zip.files['tn04'].inflate(), c => c.charCodeAt(0));
		PRG2 = Uint8Array.from(zip.files['tn05-1'].inflate(), c => c.charCodeAt(0));
		MAP = Uint8Array.from(zip.files['tn06'].inflate(), c => c.charCodeAt(0));
		game = new BalloonBomber();
		pixel = new Uint8Array(game.width * game.height * 4);
		data = new Uint32Array(pixel.buffer);
		document.onkeydown = onkeydown;
		document.onkeyup = onkeyup;
		init();
		loop();
	},
	error: function() {
		alert(filename + ': failed to get');
	}
});

</script>
</body>
</html>
